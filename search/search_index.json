{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Benchmarking with RocksDB backend"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/","text":"About about.. struct linereader { FILE * fp ; char * buf ; unsigned int buf_len ; }; def md_open ( dev_uri : str , md_dev_uri : str ) -> FlexAlloc : dev_pystr = dev_uri . encode ( \"ascii\" ) cdef char * dev_cstr = dev_pystr md_dev_pystr = md_dev_uri . encode ( \"ascii\" ) cdef char * md_dev_cstr = md_dev_pystr cdef flexalloc * data if fla_md_open ( dev_cstr , md_dev_cstr , & data ): raise MemoryError ( \"failed to open FlexAlloc system\" ) cdef FlexAlloc fs = FlexAlloc . from_ptr ( data ) return fs","title":"About FlexAlloc"},{"location":"about/#about-about","text":"struct linereader { FILE * fp ; char * buf ; unsigned int buf_len ; }; def md_open ( dev_uri : str , md_dev_uri : str ) -> FlexAlloc : dev_pystr = dev_uri . encode ( \"ascii\" ) cdef char * dev_cstr = dev_pystr md_dev_pystr = md_dev_uri . encode ( \"ascii\" ) cdef char * md_dev_cstr = md_dev_pystr cdef flexalloc * data if fla_md_open ( dev_cstr , md_dev_cstr , & data ): raise MemoryError ( \"failed to open FlexAlloc system\" ) cdef FlexAlloc fs = FlexAlloc . from_ptr ( data ) return fs","title":"About about.."},{"location":"code-conventions/","text":"Code Conventions: Code Formating All coding style like for example positions of brackets and line break and where to put the next line ... will be handled by calling the astyle script located in scripts. Line Length It will be 100 characters long. Enforced by running the astyle script. Method Signatures Return Value Always return int as error. In general methods should return an int where zero means that no errors occured and any other value means an error. If errno is detected or set within the function it should be returned as -errno If an error different from what errno defines is detected or set it should be returned as a positive number. This in order to know if it is errno or a flexalloc specific error. Return void when there are no errors to handle. Use void when there are no errors to handle within the method. This is quite rare but happens when you for example wrap a simple free. Initializing structures Pass what you are initializing to the function as a double pointer. In general methods should have a double pointer to the structure that is being initialized. For example: fla_cool_function_name ( int arg1 , int arg2 , struct fla_struct ** s ) Naming Function naming Prefix \"fla_\". In general, functions that might involve a name clash must start with \"fla_\". This includes API functions. Variable naming Prefix \"fla_\". Structure alignment pahole must not show holes in structures Test naming In general there are two types of tests: 1. Unit tests (UT) and 2. Regression tests (RT). A UT tests specific functions, it can have minimal setup but should generaly be simple calls to self contained functions. RT on the other hand, test features like being able to mount a FS or being able to write to a block. These are run to make sure that current code does not introduce regressions. when creating a regression tests you should include \" rt \" in the name, in the same way include \" ut \" when creating unit tests. Error handling For every error encountered the flexalloc_ERR_* methods should be used. These will print an error message to stderr and set the appropriate return value. Using these macros allows us to control the message format and how these get output. Error reporting Regular execution of libflexalloc should NOT output anything to std*. Only when there is an error should the stderr be used. This is true only when flexalloc_VERBOSITY is set to 0. Where desired, use the flexalloc_DBG_* macros. The output will then be shown when FlexAlloc is compiled with debugging enabled, such as the unit- and regression tests. Feature Test Macros Feature test macros allow the porgrammer to control the definitions that are exposed when including a header. As these might not be available in all environments, we choose to avoid them in flexalloc. Compile Options How to use them? To set the options you can either do it at setup or configure time. In both cases you need to add the -Doption=value to the command line in order to set the value. Options flexalloc_VERBOSITY is an int options that can either be 0 or 1. 0 will show no extra output. 1 means that messages called with flexalloc_VBS_PRINTF will be shown. It is set at 0 by default.","title":"Code Conventions"},{"location":"code-conventions/#code-conventions","text":"","title":"Code Conventions:"},{"location":"code-conventions/#code-formating","text":"All coding style like for example positions of brackets and line break and where to put the next line ... will be handled by calling the astyle script located in scripts.","title":"Code Formating"},{"location":"code-conventions/#line-length","text":"It will be 100 characters long. Enforced by running the astyle script.","title":"Line Length"},{"location":"code-conventions/#method-signatures","text":"","title":"Method Signatures"},{"location":"code-conventions/#return-value","text":"Always return int as error. In general methods should return an int where zero means that no errors occured and any other value means an error. If errno is detected or set within the function it should be returned as -errno If an error different from what errno defines is detected or set it should be returned as a positive number. This in order to know if it is errno or a flexalloc specific error. Return void when there are no errors to handle. Use void when there are no errors to handle within the method. This is quite rare but happens when you for example wrap a simple free.","title":"Return Value"},{"location":"code-conventions/#initializing-structures","text":"Pass what you are initializing to the function as a double pointer. In general methods should have a double pointer to the structure that is being initialized. For example: fla_cool_function_name ( int arg1 , int arg2 , struct fla_struct ** s )","title":"Initializing structures"},{"location":"code-conventions/#naming","text":"","title":"Naming"},{"location":"code-conventions/#function-naming","text":"Prefix \"fla_\". In general, functions that might involve a name clash must start with \"fla_\". This includes API functions.","title":"Function naming"},{"location":"code-conventions/#variable-naming","text":"Prefix \"fla_\".","title":"Variable naming"},{"location":"code-conventions/#structure-alignment","text":"pahole must not show holes in structures","title":"Structure alignment"},{"location":"code-conventions/#test-naming","text":"In general there are two types of tests: 1. Unit tests (UT) and 2. Regression tests (RT). A UT tests specific functions, it can have minimal setup but should generaly be simple calls to self contained functions. RT on the other hand, test features like being able to mount a FS or being able to write to a block. These are run to make sure that current code does not introduce regressions. when creating a regression tests you should include \" rt \" in the name, in the same way include \" ut \" when creating unit tests.","title":"Test naming"},{"location":"code-conventions/#error-handling","text":"For every error encountered the flexalloc_ERR_* methods should be used. These will print an error message to stderr and set the appropriate return value. Using these macros allows us to control the message format and how these get output.","title":"Error handling"},{"location":"code-conventions/#error-reporting","text":"Regular execution of libflexalloc should NOT output anything to std*. Only when there is an error should the stderr be used. This is true only when flexalloc_VERBOSITY is set to 0. Where desired, use the flexalloc_DBG_* macros. The output will then be shown when FlexAlloc is compiled with debugging enabled, such as the unit- and regression tests.","title":"Error reporting"},{"location":"code-conventions/#feature-test-macros","text":"Feature test macros allow the porgrammer to control the definitions that are exposed when including a header. As these might not be available in all environments, we choose to avoid them in flexalloc.","title":"Feature Test Macros"},{"location":"code-conventions/#compile-options","text":"","title":"Compile Options"},{"location":"code-conventions/#how-to-use-them","text":"To set the options you can either do it at setup or configure time. In both cases you need to add the -Doption=value to the command line in order to set the value.","title":"How to use them?"},{"location":"code-conventions/#options","text":"flexalloc_VERBOSITY is an int options that can either be 0 or 1. 0 will show no extra output. 1 means that messages called with flexalloc_VBS_PRINTF will be shown. It is set at 0 by default.","title":"Options"},{"location":"installing-flexalloc/","text":"Installing FlexAlloc Dependencies Package dependencies Meson will inform you of missing C libraries, but you will at least need the following software to build FlexAlloc: xnvme meson and ninja (see below) The meson and ninja build system You will need the meson build system. The easiest way to get the latest meson package is through pipx like so: # (replace 'python3' with 'python' if this is your Python 3 binary) python3 -m pip install --user pipx python3 -m pipx ensurepath Afterward, install meson and ninja into their own virtual environment: pipx install meson pipx runpip meson install ninja NOTE You may see errors indicating that you miss venv or virtualenv . In some Distribution, this Python module is shipped separately. For Ubuntu/Debian you will need to install the python3-venv and python3-pip packages.","title":"Installing FlexAlloc"},{"location":"installing-flexalloc/#installing-flexalloc","text":"","title":"Installing FlexAlloc"},{"location":"installing-flexalloc/#dependencies","text":"","title":"Dependencies"},{"location":"installing-flexalloc/#package-dependencies","text":"Meson will inform you of missing C libraries, but you will at least need the following software to build FlexAlloc: xnvme meson and ninja (see below)","title":"Package dependencies"},{"location":"installing-flexalloc/#the-meson-and-ninja-build-system","text":"You will need the meson build system. The easiest way to get the latest meson package is through pipx like so: # (replace 'python3' with 'python' if this is your Python 3 binary) python3 -m pip install --user pipx python3 -m pipx ensurepath Afterward, install meson and ninja into their own virtual environment: pipx install meson pipx runpip meson install ninja NOTE You may see errors indicating that you miss venv or virtualenv . In some Distribution, this Python module is shipped separately. For Ubuntu/Debian you will need to install the python3-venv and python3-pip packages.","title":"The meson and ninja build system"},{"location":"testing/","text":"Testing FlexAlloc uses the meson build system, but not its integrated unit test system, hence running meson test -C <buid-dir> will complain that no tests are defined! Instead, FlexAlloc Why FlexAlloc uses Python for testing As FlexAlloc has grown, we have migrated away from meson's unit testing system in favor of testing FlexAlloc in Pytest using pyflexalloc, our Python language bindings. FlexAlloc tests try to test the entire system, and must format (test) devices, initialize loop devices, spawn and manage daemons in the background to test multi-tenant support and so on - implementing this logic in Python is significantly easier. At the same time, Pytest is a much more advanced testing framework, supporting parametrized tests , test fixtures , the ability to mark/tag tests and to execute only tests with these tags ( markers ), automatic test discovery and more. Getting Started Where are tests located? FlexAlloc presently has some unit tests in C and some in Python. We plan to migrate all tests to Python, but all tests are already run via Pytest. The C-based tests are in tests/ and python wrappers are generated for each test by meson, based on the template in tests/flexalloc_pyt.py.in . In this way, these tests are automatically discovered and run by Pytest. The Python-based tests are in pyflexalloc/tests and follow standard Pytest conventions. Pytest's test discovery mechanism recursively scans for files following the naming convention test_<name>.py , executing each test function herein following the name convention test_<name> . Running all tests To run all tests, run meson compile -C <build-dir> run-tests , this both recompiles the C library and the Python bindings, and finally runs all unit tests using Pytest . Customize the test command Customizing the exact command run for testing is very useful during debugging. You can run only a specific subset of tests or use other programs like catchsegv to provide detailed output in event of a segfault. To run the tests first requires configuring the environment. To make this otherwise involved process easy, we provide scripts/run . Just use MESON_BUILD_ROOT=<build-dir> ./scripts/run <command> and the script will configure the environment. Catching segmentation fault information One way to help debugging sudden segfaults is to the the catchsegv program, distributed as part of libc-bin on Debian-based systems: From the root of the FlexAlloc source directory, run: MESON_BUILD_ROOT=<build-dir> ./scripts/run catchsegv pytest pyflexalloc/tests In event of a crash, a stack trace of the C code will be emitted, pinpointing the function in which some code triggered the segmentation fault. Run a subset of tests See debug output during execution To customize the pytest command, you can instead triggers a recompile of the core FlexAlloc C library, the Python language bindings Mesons unit test support is workable, but rudimentary, and many FlexAlloc tests are initializing loop devices (and their backing files), running daemons in the background, formatting devices and the like FlexAlloc uses the meson build system, which permits unit testing through writing a series of small binaries whose exit codes determine test success or failure. As FlexAlloc has grown, we have migrated away from this approach in favor of using Pytest to test FlexAlloc through our Python language bindings. As a consequence, running meson test -C <build-dir> will complain that no tests are defined! Using Python significantly reduces the toil of test setup, while providing an extensive set of tools for unit testing through Pytest , such as parametrized testing, advanced failure reporting with diff-support, shared test fixtures for common setup code (loop and hardware device setup and allocation) and so on. Getting Started such as allocating loop devices, initializing their backing files etc, while providing all the features FlexAlloc has migrated away from this approach as As FlexAlloc has grown, we have which Flexalloc uses, supports unit testing by MESON_SOURCE_ROOT = ` pwd ` MESON_BUILD_ROOT = ` pwd ` /build ./scripts/run catchsegv pytest -s pyflexalloc/tests","title":"Testing"},{"location":"testing/#testing","text":"FlexAlloc uses the meson build system, but not its integrated unit test system, hence running meson test -C <buid-dir> will complain that no tests are defined! Instead, FlexAlloc","title":"Testing"},{"location":"testing/#why-flexalloc-uses-python-for-testing","text":"As FlexAlloc has grown, we have migrated away from meson's unit testing system in favor of testing FlexAlloc in Pytest using pyflexalloc, our Python language bindings. FlexAlloc tests try to test the entire system, and must format (test) devices, initialize loop devices, spawn and manage daemons in the background to test multi-tenant support and so on - implementing this logic in Python is significantly easier. At the same time, Pytest is a much more advanced testing framework, supporting parametrized tests , test fixtures , the ability to mark/tag tests and to execute only tests with these tags ( markers ), automatic test discovery and more.","title":"Why FlexAlloc uses Python for testing"},{"location":"testing/#getting-started","text":"","title":"Getting Started"},{"location":"testing/#where-are-tests-located","text":"FlexAlloc presently has some unit tests in C and some in Python. We plan to migrate all tests to Python, but all tests are already run via Pytest. The C-based tests are in tests/ and python wrappers are generated for each test by meson, based on the template in tests/flexalloc_pyt.py.in . In this way, these tests are automatically discovered and run by Pytest. The Python-based tests are in pyflexalloc/tests and follow standard Pytest conventions. Pytest's test discovery mechanism recursively scans for files following the naming convention test_<name>.py , executing each test function herein following the name convention test_<name> .","title":"Where are tests located?"},{"location":"testing/#running-all-tests","text":"To run all tests, run meson compile -C <build-dir> run-tests , this both recompiles the C library and the Python bindings, and finally runs all unit tests using Pytest .","title":"Running all tests"},{"location":"testing/#customize-the-test-command","text":"Customizing the exact command run for testing is very useful during debugging. You can run only a specific subset of tests or use other programs like catchsegv to provide detailed output in event of a segfault. To run the tests first requires configuring the environment. To make this otherwise involved process easy, we provide scripts/run . Just use MESON_BUILD_ROOT=<build-dir> ./scripts/run <command> and the script will configure the environment.","title":"Customize the test command"},{"location":"testing/#catching-segmentation-fault-information","text":"One way to help debugging sudden segfaults is to the the catchsegv program, distributed as part of libc-bin on Debian-based systems: From the root of the FlexAlloc source directory, run: MESON_BUILD_ROOT=<build-dir> ./scripts/run catchsegv pytest pyflexalloc/tests In event of a crash, a stack trace of the C code will be emitted, pinpointing the function in which some code triggered the segmentation fault.","title":"Catching segmentation fault information"},{"location":"testing/#run-a-subset-of-tests","text":"","title":"Run a subset of tests"},{"location":"testing/#see-debug-output-during-execution","text":"To customize the pytest command, you can instead triggers a recompile of the core FlexAlloc C library, the Python language bindings Mesons unit test support is workable, but rudimentary, and many FlexAlloc tests are initializing loop devices (and their backing files), running daemons in the background, formatting devices and the like FlexAlloc uses the meson build system, which permits unit testing through writing a series of small binaries whose exit codes determine test success or failure. As FlexAlloc has grown, we have migrated away from this approach in favor of using Pytest to test FlexAlloc through our Python language bindings. As a consequence, running meson test -C <build-dir> will complain that no tests are defined! Using Python significantly reduces the toil of test setup, while providing an extensive set of tools for unit testing through Pytest , such as parametrized testing, advanced failure reporting with diff-support, shared test fixtures for common setup code (loop and hardware device setup and allocation) and so on.","title":"See debug output during execution"},{"location":"testing/#getting-started_1","text":"such as allocating loop devices, initializing their backing files etc, while providing all the features FlexAlloc has migrated away from this approach as As FlexAlloc has grown, we have which Flexalloc uses, supports unit testing by MESON_SOURCE_ROOT = ` pwd ` MESON_BUILD_ROOT = ` pwd ` /build ./scripts/run catchsegv pytest -s pyflexalloc/tests","title":"Getting Started"},{"location":"blog/20220201-welcome/","text":"Welcome Blog Post...","title":"Welcome"},{"location":"blog/20220201-welcome/#welcome-blog-post","text":"","title":"Welcome Blog Post..."}]}